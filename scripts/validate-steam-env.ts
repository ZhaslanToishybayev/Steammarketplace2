#!/usr/bin/env ts-node

import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import axios from 'axios';
import { Client as PgClient } from 'pg';
import { MongoClient } from 'mongodb';
import { Redis } from 'ioredis';

// Load environment variables
dotenv.config({ path: path.join(__dirname, '../apps/backend/.env') });

interface ValidationResult {
  name: string;
  status: 'PASS' | 'FAIL' | 'WARN';
  message: string;
  details?: any;
}

class EnvironmentValidator {
  private results: ValidationResult[] = [];

  constructor(
    private fix = false,
    private strict = false,
    private outputFile?: string
  ) {}

  private log(message: string, color: 'green' | 'red' | 'yellow' | 'blue' | 'gray' = 'gray') {
    console.log(chalk[color](message));
  }

  private validateEnvVar(name: string, required = true, validator?: (value: string) => boolean): ValidationResult {
    const value = process.env[name];

    if (!value) {
      if (required) {
        return {
          name,
          status: 'FAIL',
          message: `${name} is required but not set`
        };
      } else {
        return {
          name,
          status: 'PASS',
          message: `${name} is not set (optional)`
        };
      }
    }

    if (validator && !validator(value)) {
      return {
        name,
        status: 'FAIL',
        message: `${name} has invalid format or value`
      };
    }

    return {
      name,
      status: 'PASS',
      message: `${name} is set correctly`
    };
  }

  async validateSteamAPIKey(): Promise<ValidationResult> {
    const apiKey = process.env.STEAM_API_KEY;

    if (!apiKey) {
      return {
        name: 'STEAM_API_KEY',
        status: 'FAIL',
        message: 'STEAM_API_KEY is required'
      };
    }

    // Basic format validation
    if (!/^[A-F0-9]{32}$/.test(apiKey)) {
      return {
        name: 'STEAM_API_KEY',
        status: 'FAIL',
        message: 'STEAM_API_KEY must be 32 hexadecimal characters'
      };
    }

    // Test API key validity
    return await this.testSteamAPIKey(apiKey);
  }

  private async testSteamAPIKey(apiKey: string): Promise<ValidationResult> {
    try {
      const response = await axios.get(
        'https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/',
        {
          params: {
            key: apiKey,
            steamids: '76561197960435530' // Gabe Newell's Steam ID
          },
          timeout: 10000
        }
      );

      if (response.status === 200 && response.data.response.players.length > 0) {
        return {
          name: 'STEAM_API_KEY',
          status: 'PASS',
          message: 'STEAM_API_KEY is valid and working'
        };
      } else {
        return {
          name: 'STEAM_API_KEY',
          status: 'FAIL',
          message: 'STEAM_API_KEY is invalid or not working'
        };
      }
    } catch (error) {
      return {
        name: 'STEAM_API_KEY',
        status: 'FAIL',
        message: `STEAM_API_KEY test failed: ${error instanceof Error ? error.message : error}`
      };
    }
  }

  validateBotCredentials(): ValidationResult {
    const encryptionKey = process.env.BOT_ENCRYPTION_KEY;

    if (!encryptionKey) {
      return {
        name: 'BOT_ENCRYPTION_KEY',
        status: 'FAIL',
        message: 'BOT_ENCRYPTION_KEY is required'
      };
    }

    // Check minimum length
    if (encryptionKey.length < 32) {
      return {
        name: 'BOT_ENCRYPTION_KEY',
        status: 'FAIL',
        message: 'BOT_ENCRYPTION_KEY must be at least 32 characters long'
      };
    }

    // Check for weak patterns
    const weakPatterns = [
      /^(test|dev|demo|123|password)/i,
      /^(.+)123$/,
      /^(.+)111$/,
      /^(.+)222$/
    ];

    for (const pattern of weakPatterns) {
      if (pattern.test(encryptionKey)) {
        if (this.fix) {
          const newKey = this.generateEncryptionKey();
          process.env.BOT_ENCRYPTION_KEY = newKey;
          this.updateEnvFile('BOT_ENCRYPTION_KEY', newKey);
          return {
            name: 'BOT_ENCRYPTION_KEY',
            status: 'PASS',
            message: 'BOT_ENCRYPTION_KEY was weak and has been auto-generated',
            details: { autoGenerated: true }
          };
        } else {
          return {
            name: 'BOT_ENCRYPTION_KEY',
            status: 'WARN',
            message: 'BOT_ENCRYPTION_KEY appears weak. Consider using a stronger key or use --fix to auto-generate',
            details: { weakPattern: true }
          };
        }
      }
    }

    return {
      name: 'BOT_ENCRYPTION_KEY',
      status: 'PASS',
      message: 'BOT_ENCRYPTION_KEY is strong and valid'
    };
  }

  private generateEncryptionKey(): string {
    const crypto = require('crypto');
    return crypto.randomBytes(32).toString('hex');
  }

  validateDatabaseConfig(): ValidationResult {
    const requiredVars = [
      'POSTGRES_HOST',
      'POSTGRES_PORT',
      'POSTGRES_USER',
      'POSTGRES_PASSWORD',
      'POSTGRES_DB',
      'MONGODB_URI',
      'REDIS_HOST',
      'REDIS_PORT'
    ];

    const results: ValidationResult[] = [];

    for (const varName of requiredVars) {
      const result = this.validateEnvVar(varName, true, (value) => {
        if (varName === 'POSTGRES_PORT' || varName === 'REDIS_PORT') {
          return /^\d+$/.test(value) && parseInt(value) > 0 && parseInt(value) <= 65535;
        }
        return value.length > 0;
      });
      results.push(result);
    }

    const failed = results.filter(r => r.status === 'FAIL');
    const warnings = results.filter(r => r.status === 'WARN');

    if (failed.length > 0) {
      return {
        name: 'Database Configuration',
        status: 'FAIL',
        message: `${failed.length} database configuration variables are invalid`,
        details: { failedVars: failed.map(r => r.name) }
      };
    } else if (warnings.length > 0) {
      return {
        name: 'Database Configuration',
        status: 'WARN',
        message: `${warnings.length} database configuration issues found`,
        details: { warningVars: warnings.map(r => r.name) }
      };
    } else {
      return {
        name: 'Database Configuration',
        status: 'PASS',
        message: 'All database configuration variables are valid'
      };
    }
  }

  validateJWTConfig(): ValidationResult {
    const jwtSecret = process.env.JWT_SECRET;
    const jwtRefreshSecret = process.env.JWT_REFRESH_SECRET;

    const results: ValidationResult[] = [];

    // Validate JWT_SECRET
    if (!jwtSecret) {
      results.push({
        name: 'JWT_SECRET',
        status: 'FAIL',
        message: 'JWT_SECRET is required'
      });
    } else if (jwtSecret.length < 32) {
      results.push({
        name: 'JWT_SECRET',
        status: 'FAIL',
        message: 'JWT_SECRET must be at least 32 characters long'
      });
    } else if (this.isWeakSecret(jwtSecret)) {
      if (this.fix) {
        const newSecret = this.generateEncryptionKey();
        process.env.JWT_SECRET = newSecret;
        this.updateEnvFile('JWT_SECRET', newSecret);
        results.push({
          name: 'JWT_SECRET',
          status: 'PASS',
          message: 'JWT_SECRET was weak and has been auto-generated',
          details: { autoGenerated: true }
        });
      } else {
        results.push({
          name: 'JWT_SECRET',
          status: 'WARN',
          message: 'JWT_SECRET appears weak. Consider using a stronger secret or use --fix to auto-generate'
        });
      }
    } else {
      results.push({
        name: 'JWT_SECRET',
        status: 'PASS',
        message: 'JWT_SECRET is strong and valid'
      });
    }

    // Validate JWT_REFRESH_SECRET
    if (!jwtRefreshSecret) {
      results.push({
        name: 'JWT_REFRESH_SECRET',
        status: 'FAIL',
        message: 'JWT_REFRESH_SECRET is required'
      });
    } else if (jwtRefreshSecret.length < 32) {
      results.push({
        name: 'JWT_REFRESH_SECRET',
        status: 'FAIL',
        message: 'JWT_REFRESH_SECRET must be at least 32 characters long'
      });
    } else if (this.isWeakSecret(jwtRefreshSecret)) {
      if (this.fix) {
        const newSecret = this.generateEncryptionKey();
        process.env.JWT_REFRESH_SECRET = newSecret;
        this.updateEnvFile('JWT_REFRESH_SECRET', newSecret);
        results.push({
          name: 'JWT_REFRESH_SECRET',
          status: 'PASS',
          message: 'JWT_REFRESH_SECRET was weak and has been auto-generated',
          details: { autoGenerated: true }
        });
      } else {
        results.push({
          name: 'JWT_REFRESH_SECRET',
          status: 'WARN',
          message: 'JWT_REFRESH_SECRET appears weak. Consider using a stronger secret or use --fix to auto-generate'
        });
      }
    } else {
      results.push({
        name: 'JWT_REFRESH_SECRET',
        status: 'PASS',
        message: 'JWT_REFRESH_SECRET is strong and valid'
      });
    }

    // Check JWT expiration formats
    const expiresIn = process.env.JWT_EXPIRES_IN || '1h';
    const refreshExpiresIn = process.env.JWT_REFRESH_EXPIRES_IN || '7d';

    let expiresInValid = true;
    let refreshExpiresInValid = true;

    try {
      // Basic validation for time formats like "1h", "7d", "60s"
      if (!/^\d+[smhd]$/.test(expiresIn)) {
        expiresInValid = false;
      }
      if (!/^\d+[smhd]$/.test(refreshExpiresIn)) {
        refreshExpiresInValid = false;
      }
    } catch {
      expiresInValid = false;
      refreshExpiresInValid = false;
    }

    if (!expiresInValid) {
      results.push({
        name: 'JWT_EXPIRES_IN',
        status: 'FAIL',
        message: 'JWT_EXPIRES_IN must be in format like "1h", "7d", "60s"'
      });
    }

    if (!refreshExpiresInValid) {
      results.push({
        name: 'JWT_REFRESH_EXPIRES_IN',
        status: 'FAIL',
        message: 'JWT_REFRESH_EXPIRES_IN must be in format like "1h", "7d", "60s"'
      });
    }

    const failed = results.filter(r => r.status === 'FAIL');
    const warnings = results.filter(r => r.status === 'WARN');

    if (failed.length > 0) {
      return {
        name: 'JWT Configuration',
        status: 'FAIL',
        message: `${failed.length} JWT configuration issues found`,
        details: { failedVars: failed.map(r => r.name) }
      };
    } else if (warnings.length > 0) {
      return {
        name: 'JWT Configuration',
        status: 'WARN',
        message: `${warnings.length} JWT configuration warnings found`,
        details: { warningVars: warnings.map(r => r.name) }
      };
    } else {
      return {
        name: 'JWT Configuration',
        status: 'PASS',
        message: 'JWT configuration is valid and secure'
      };
    }
  }

  private isWeakSecret(secret: string): boolean {
    const weakPatterns = [
      /^(test|dev|demo|123|password|secret)/i,
      /^(.+)123$/,
      /^(.+)111$/,
      /^(.+)222$/,
      /^(secret|jwt|token)$/,
      /^(.+)\1$/ // Repeated patterns
    ];

    return weakPatterns.some(pattern => pattern.test(secret));
  }

  validateSteamOAuthConfig(): ValidationResult {
    const realm = process.env.STEAM_REALM;
    const returnUrl = process.env.STEAM_RETURN_URL;

    const results: ValidationResult[] = [];

    // Validate STEAM_REALM
    if (!realm) {
      results.push({
        name: 'STEAM_REALM',
        status: 'FAIL',
        message: 'STEAM_REALM is required'
      });
    } else if (!this.isValidUrl(realm)) {
      results.push({
        name: 'STEAM_REALM',
        status: 'FAIL',
        message: 'STEAM_REALM must be a valid URL'
      });
    } else if (process.env.NODE_ENV === 'production' && realm.includes('localhost')) {
      results.push({
        name: 'STEAM_REALM',
        status: 'WARN',
        message: 'STEAM_REALM should not use localhost in production'
      });
    } else {
      results.push({
        name: 'STEAM_REALM',
        status: 'PASS',
        message: 'STEAM_REALM is valid'
      });
    }

    // Validate STEAM_RETURN_URL
    if (!returnUrl) {
      results.push({
        name: 'STEAM_RETURN_URL',
        status: 'FAIL',
        message: 'STEAM_RETURN_URL is required'
      });
    } else if (!this.isValidUrl(returnUrl)) {
      results.push({
        name: 'STEAM_RETURN_URL',
        status: 'FAIL',
        message: 'STEAM_RETURN_URL must be a valid URL'
      });
    } else if (!returnUrl.endsWith('/api/auth/steam/return')) {
      results.push({
        name: 'STEAM_RETURN_URL',
        status: 'WARN',
        message: 'STEAM_RETURN_URL should end with /api/auth/steam/return'
      });
    } else {
      results.push({
        name: 'STEAM_RETURN_URL',
        status: 'PASS',
        message: 'STEAM_RETURN_URL is valid'
      });
    }

    const failed = results.filter(r => r.status === 'FAIL');
    const warnings = results.filter(r => r.status === 'WARN');

    if (failed.length > 0) {
      return {
        name: 'Steam OAuth Configuration',
        status: 'FAIL',
        message: `${failed.length} Steam OAuth configuration issues found`,
        details: { failedVars: failed.map(r => r.name) }
      };
    } else if (warnings.length > 0) {
      return {
        name: 'Steam OAuth Configuration',
        status: 'WARN',
        message: `${warnings.length} Steam OAuth configuration warnings found`,
        details: { warningVars: warnings.map(r => r.name) }
      };
    } else {
      return {
        name: 'Steam OAuth Configuration',
        status: 'PASS',
        message: 'Steam OAuth configuration is valid'
      };
    }
  }

  private isValidUrl(string: string): boolean {
    try {
      new URL(string);
      return true;
    } catch {
      return false;
    }
  }

  async testDatabaseConnections(): Promise<ValidationResult> {
    const results: ValidationResult[] = [];

    // Test PostgreSQL
    try {
      const pgClient = new PgClient({
        host: process.env.POSTGRES_HOST || 'localhost',
        port: parseInt(process.env.POSTGRES_PORT || '5432'),
        user: process.env.POSTGRES_USER || 'steam_user',
        password: process.env.POSTGRES_PASSWORD,
        database: process.env.POSTGRES_DB || 'steam_marketplace',
        connectionTimeoutMillis: 5000
      });

      await pgClient.connect();
      const result = await pgClient.query('SELECT 1 as test');
      await pgClient.end();

      if (result.rows[0].test === 1) {
        results.push({
          name: 'PostgreSQL Connection',
          status: 'PASS',
          message: 'PostgreSQL connection successful'
        });
      } else {
        results.push({
          name: 'PostgreSQL Connection',
          status: 'FAIL',
          message: 'PostgreSQL connection test failed'
        });
      }
    } catch (error) {
      results.push({
        name: 'PostgreSQL Connection',
        status: 'FAIL',
        message: `PostgreSQL connection failed: ${error instanceof Error ? error.message : error}`
      });
    }

    // Test MongoDB
    try {
      const mongoClient = new MongoClient(process.env.MONGODB_URI || 'mongodb://localhost:27017/steam_marketplace', {
        serverSelectionTimeoutMS: 5000
      });

      await mongoClient.connect();
      await mongoClient.db().admin().command({ ping: 1 });
      await mongoClient.close();

      results.push({
        name: 'MongoDB Connection',
        status: 'PASS',
        message: 'MongoDB connection successful'
      });
    } catch (error) {
      results.push({
        name: 'MongoDB Connection',
        status: 'FAIL',
        message: `MongoDB connection failed: ${error instanceof Error ? error.message : error}`
      });
    }

    // Test Redis
    try {
      const redis = new Redis({
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        lazyConnect: true
      });

      await redis.ping();
      await redis.disconnect();

      results.push({
        name: 'Redis Connection',
        status: 'PASS',
        message: 'Redis connection successful'
      });
    } catch (error) {
      results.push({
        name: 'Redis Connection',
        status: 'FAIL',
        message: `Redis connection failed: ${error instanceof Error ? error.message : error}`
      });
    }

    const failed = results.filter(r => r.status === 'FAIL');

    if (failed.length > 0) {
      return {
        name: 'Database Connections',
        status: 'FAIL',
        message: `${failed.length} database connections failed`,
        details: { failedConnections: failed.map(r => r.name) }
      };
    } else {
      return {
        name: 'Database Connections',
        status: 'PASS',
        message: 'All database connections successful'
      };
    }
  }

  async checkPortAvailability(): Promise<ValidationResult> {
    const ports = [3000, 3001]; // Frontend and Backend ports
    const results: ValidationResult[] = [];

    for (const port of ports) {
      try {
        const net = require('net');
        const server = net.createServer();

        await new Promise<void>((resolve, reject) => {
          server.listen(port, 'localhost');
          server.on('listening', () => {
            server.close();
            resolve();
          });
          server.on('error', (error: any) => {
            if (error.code === 'EADDRINUSE') {
              results.push({
                name: `Port ${port}`,
                status: 'FAIL',
                message: `Port ${port} is already in use`
              });
            } else {
              results.push({
                name: `Port ${port}`,
                status: 'FAIL',
                message: `Port ${port} check failed: ${error.message}`
              });
            }
            reject(error);
          });
        });
      } catch (error) {
        // Port is in use or error occurred
        if (results.filter(r => r.name === `Port ${port}`).length === 0) {
          results.push({
            name: `Port ${port}`,
            status: 'FAIL',
            message: `Port ${port} is not available`
          });
        }
      }
    }

    const failed = results.filter(r => r.status === 'FAIL');

    if (failed.length > 0) {
      return {
        name: 'Port Availability',
        status: 'FAIL',
        message: `${failed.length} ports are not available`,
        details: { unavailablePorts: failed.map(r => r.name) }
      };
    } else {
      return {
        name: 'Port Availability',
        status: 'PASS',
        message: 'All required ports are available'
      };
    }
  }

  private updateEnvFile(key: string, value: string): void {
    const envPath = path.join(__dirname, '../apps/backend/.env');
    let envContent = '';

    try {
      envContent = fs.readFileSync(envPath, 'utf8');
    } catch {
      this.log('Warning: Could not read .env file for updates', 'yellow');
      return;
    }

    const keyPattern = new RegExp(`^${key}=.*$`, 'm');
    const newLine = `${key}=${value}`;

    if (keyPattern.test(envContent)) {
      envContent = envContent.replace(keyPattern, newLine);
    } else {
      envContent += `\n${key}=${value}\n`;
    }

    try {
      fs.writeFileSync(envPath, envContent);
      this.log(`Updated ${key} in .env file`, 'green');
    } catch (error) {
      this.log(`Failed to update .env file: ${error instanceof Error ? error.message : error}`, 'red');
    }
  }

  async runAllValidations(): Promise<void> {
    console.log(chalk.blue.bold('ðŸ” Starting Environment Validation...\n'));

    // Basic environment variable checks
    this.results.push(this.validateEnvVar('NODE_ENV', false));
    this.results.push(this.validateEnvVar('LOG_LEVEL', false));

    // Steam-specific validations
    this.results.push(await this.validateSteamAPIKey());
    this.results.push(this.validateBotCredentials());
    this.results.push(this.validateSteamOAuthConfig());

    // Database validations
    this.results.push(this.validateDatabaseConfig());
    this.results.push(await this.testDatabaseConnections());

    // JWT validations
    this.results.push(this.validateJWTConfig());

    // System validations
    this.results.push(await this.checkPortAvailability());

    // Generate report
    this.generateReport();
  }

  private generateReport(): void {
    const totalTests = this.results.length;
    const passedTests = this.results.filter(r => r.status === 'PASS').length;
    const failedTests = this.results.filter(r => r.status === 'FAIL').length;
    const warningTests = this.results.filter(r => r.status === 'WARN').length;

    console.log('\n' + '='.repeat(80));
    console.log(chalk.blue.bold('ðŸ” ENVIRONMENT VALIDATION REPORT'));
    console.log('='.repeat(80));

    console.log(`\nðŸ“Š Summary:`);
    console.log(`   Total Checks: ${totalTests}`);
    console.log(`   âœ… Passed: ${passedTests}`);
    console.log(`   âš ï¸  Warnings: ${warningTests}`);
    console.log(`   âŒ Failed: ${failedTests}`);

    const passRate = totalTests > 0 ? (passedTests / totalTests) * 100 : 0;
    console.log(`   ðŸ“ˆ Pass Rate: ${passRate.toFixed(1)}%`);

    console.log(`\nðŸ“‹ Detailed Results:`);
    this.results.forEach((result, index) => {
      const statusIcon = result.status === 'PASS' ? 'âœ…' :
                        result.status === 'WARN' ? 'âš ï¸' : 'âŒ';
      const statusColor = result.status === 'PASS' ? 'green' :
                         result.status === 'WARN' ? 'yellow' : 'red';

      console.log(`   ${index + 1}. ${statusIcon} ${result.name}`);
      console.log(`      ${result.message}`);
    });

    if (failedTests > 0) {
      console.log(`\nâŒ Failed Checks:`);
      this.results.filter(r => r.status === 'FAIL').forEach((result, index) => {
        console.log(`   ${index + 1}. ${result.name}: ${result.message}`);
        if (result.details && result.details.failedVars) {
          console.log(`      Failed variables: ${result.details.failedVars.join(', ')}`);
        }
      });
    }

    if (warningTests > 0) {
      console.log(`\nâš ï¸ Warning Checks:`);
      this.results.filter(r => r.status === 'WARN').forEach((result, index) => {
        console.log(`   ${index + 1}. ${result.name}: ${result.message}`);
      });
    }

    // Determine overall status
    let overallStatus = 'PASS';
    let statusMessage = '';

    if (failedTests > 0) {
      overallStatus = 'FAIL';
      statusMessage = 'âŒ Environment validation failed. Please fix the issues above before proceeding.';
    } else if (warningTests > 0 && this.strict) {
      overallStatus = 'FAIL';
      statusMessage = 'âš ï¸ Environment validation failed in strict mode due to warnings.';
    } else if (warningTests > 0) {
      overallStatus = 'WARN';
      statusMessage = 'âš ï¸ Environment validation passed with warnings. Consider addressing them for better security.';
    } else {
      statusMessage = 'âœ… Environment validation passed. All configurations are correct.';
    }

    console.log(`\nðŸŽ¯ Overall Status: ${overallStatus === 'PASS' ? chalk.green.bold('PASS') :
                                           overallStatus === 'WARN' ? chalk.yellow.bold('WARN') :
                                           chalk.red.bold('FAIL')}`);
    console.log(statusMessage);

    // Save report to file if requested
    if (this.outputFile) {
      const reportData = {
        timestamp: new Date().toISOString(),
        summary: {
          total: totalTests,
          passed: passedTests,
          warnings: warningTests,
          failed: failedTests,
          passRate: passRate,
          overallStatus: overallStatus
        },
        results: this.results,
        recommendations: this.generateRecommendations()
      };

      const reportsDir = path.dirname(this.outputFile);
      if (!fs.existsSync(reportsDir)) {
        fs.mkdirSync(reportsDir, { recursive: true });
      }

      fs.writeFileSync(this.outputFile, JSON.stringify(reportData, null, 2));
      console.log(`\nðŸ“„ Report saved to: ${this.outputFile}`);
    }

    // Show recommendations
    if (overallStatus !== 'PASS') {
      console.log(`\nðŸ’¡ Recommendations:`);
      this.generateRecommendations().forEach((rec, index) => {
        console.log(`   ${index + 1}. ${rec}`);
      });
    }
  }

  private generateRecommendations(): string[] {
    const recommendations: string[] = [];

    this.results.forEach(result => {
      if (result.status === 'FAIL') {
        switch (result.name) {
          case 'STEAM_API_KEY':
            recommendations.push('Get a valid Steam API key from https://steamcommunity.com/dev/apikey');
            break;
          case 'BOT_ENCRYPTION_KEY':
            recommendations.push('Generate a strong encryption key using: openssl rand -hex 32');
            break;
          case 'Database Configuration':
            recommendations.push('Check database connection strings and credentials in .env file');
            break;
          case 'JWT Configuration':
            recommendations.push('Generate strong JWT secrets using: openssl rand -hex 32');
            break;
          case 'Database Connections':
            recommendations.push('Ensure all database services are running: docker-compose up -d');
            break;
          case 'Port Availability':
            recommendations.push('Stop services using required ports or change port configuration');
            break;
        }
      }
    });

    if (this.results.some(r => r.status === 'WARN')) {
      recommendations.push('Consider using --fix flag to auto-generate weak secrets and keys');
    }

    return recommendations;
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const fix = args.includes('--fix');
  const strict = args.includes('--strict');
  let outputFile = args.find((arg, index) => args[index - 1] === '--output');

  if (outputFile && !args.includes('--output')) {
    outputFile = undefined;
  }

  if (!outputFile && args.includes('--output')) {
    outputFile = `scripts/reports/env-validation-${Date.now()}.json`;
  }

  const validator = new EnvironmentValidator(fix, strict, outputFile);
  await validator.runAllValidations();

  // Exit with error code if validation failed
  const failedTests = validator['results'].filter(r => r.status === 'FAIL').length;
  const hasWarnings = validator['results'].some(r => r.status === 'WARN');

  if (failedTests > 0 || (strict && hasWarnings)) {
    process.exit(1);
  }
}

// Handle unhandled errors
process.on('unhandledRejection', (error) => {
  console.error(chalk.red('Unhandled Promise Rejection:'), error);
  process.exit(1);
});

process.on('uncaughtException', (error) => {
  console.error(chalk.red('Uncaught Exception:'), error);
  process.exit(1);
});

// Run if called directly
if (require.main === module) {
  main().catch((error) => {
    console.error(chalk.red('Fatal Error:'), error);
    process.exit(1);
  });
}

export { EnvironmentValidator };